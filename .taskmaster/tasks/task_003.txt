# Task ID: 3
# Title: Auth, Sessions, RBAC, MFA, OIDC, Magic Link + Frontend Guards
# Status: pending
# Dependencies: 1, 2
# Priority: high
# Description: Implement registration, login (email/password, Google OIDC, magic link), JWT access (30m) and refresh tokens (7d with rotation/revocation), MFA (TOTP for admin/critical actions), RBAC (user/admin). Frontend route guards, CSRF/XSS protections, rate limiting, session idle logout.
# Details:
Backend (FastAPI):
- Passwords: argon2-cffi 23.x with pepper and unique salts; strong policy check
- JWT: PyJWT 2.8; access token (30m) in Authorization Bearer; refresh token as httpOnly, Secure, SameSite=Strict cookie; rotation on refresh with sessions table (refresh_token_hash unique), device_fingerprint stored
- RBAC: role in JWT claims; scope checks per endpoint via dependency
- OIDC (Google): Authlib 1.3; PKCE + state; store oidc sub mapping to user; logs oidc_login
- Magic link: single-use signed token (itsdangerous or custom HMAC) TTL 15m; logged as magic_link_issued/consumed
- MFA: pyotp + qrcode; enforce for admin or sensitive actions; backup codes table optional
- CSRF: double-submit token for browser POST/PUT/DELETE: set csrf cookie + require X-CSRF-Token; validate when Authorization header present
- Rate limit: fastapi-limiter + Redis (e.g., 5/min login, 30/min AI prompt)
- Security headers: Starlette middleware (CSP, HSTS, X-Frame-Options deny); sanitize inputs; SQLAlchemy ORM prevents SQLi; PII masking in logs
- Dev mode: env flag; if dev, bypass guards and tag outputs dev_mode=true; disabled in prod via config
- Logging: all auth events to audit_logs + security_events with masked PII
Frontend (Next.js):
- i18next Turkish default; localized errors
- React Hook Form dynamic validation
- Auth pages for login/register, OIDC callback, magic link consumption
- Route guard (middleware.ts): if no access token or /license/me shows expired → redirect to license page; show banner with remaining days; idle timer auto-logout
Pseudocode (refresh rotation):
- POST /auth/token/refresh:
  - read refresh cookie → verify, lookup session by hash → if revoked: 401
  - issue new access + new refresh; mark old session revoked_at; insert new session
  - set-cookie new refresh; return access


# Test Strategy:
Unit: password policy, JWT create/verify, refresh rotation, MFA verification, CSRF checks. Integration: OIDC login flow with mocked Google, magic link single-use. Rate limit enforced (429). Frontend: Playwright tests for route guard redirects, idle logout, Turkish UI strings. Security: ZAP scan for XSS/CSRF; brute-force throttling verified.

# Subtasks:
## 1. Password Authentication (Argon2 + Pepper + Policy) [pending]
### Dependencies: None
### Description: Implement email/password registration and login with Argon2 hashing, pepper, unique salts, and strong password policy enforcement.
### Details:
Design:
- Use argon2-cffi 23.x (argon2id) with per-user salts and a global pepper (ENV: AUTH_PASSWORD_PEPPER).
- Enforce strong password policy: length >= 12, upper/lower/number/symbol, block top-10k and repeated patterns.
- Optional account lockout counter (e.g., soft lock for 15m after 10 failed attempts) in addition to rate limiting.
APIs:
- POST /auth/register {email, password, name?} → 201 {user_id}. 409 if email exists.
- POST /auth/login {email, password, device_fingerprint?, mfa_code?} → 200 {access_token, expires_in, mfa_required?}. Sets refresh cookie if MFA satisfied.
- POST /auth/password/strength {password} → 200 {score, ok, feedback}.
- POST /auth/password/forgot {email} → 202 {}.
- POST /auth/password/reset {token, new_password} → 200 {}.
Cookies: N/A (refresh set by Subtask 3).
Errors:
- 400 ERR-AUTH-INVALID-BODY, 401 ERR-AUTH-INVALID-CREDS, 423 ERR-AUTH-LOCKED, 409 ERR-AUTH-EMAIL-TAKEN.
Acceptance:
- Hash uses argon2id with configured parameters; pepper required; passwords failing policy rejected.
- Login succeeds with correct creds; fails with incorrect; lockout triggers after threshold; does not leak timing/PII.
Logging:
- audit_logs: user_registered, login_succeeded, login_failed (mask email), password_reset_requested, password_reset_completed.
- security_events: excessive_login_failures, account_locked.

## 2. Sessions Table and Device Fingerprint [pending]
### Dependencies: None
### Description: Create sessions persistence for refresh rotation with hashed refresh_token, device metadata, and revocation fields.
### Details:
Design (DB/model):
- Table sessions: id (uuid), user_id (fk users), refresh_token_hash (unique, sha256/HMAC), device_fingerprint (string), ip, user_agent, created_at, last_used_at, expires_at (7d), revoked_at, rotated_from (fk sessions.id), reason.
- Indexes: user_id, (user_id, revoked_at IS NULL), expires_at.
- Store only hash of refresh token; never store plaintext.
APIs: N/A (internal usage by auth flows).
Cookies: N/A.
Errors: N/A.
Acceptance:
- Unique constraint enforced on refresh_token_hash; revoked_at prevents reuse.
- Rotation chain (rotated_from) preserved; device_fingerprint stored when provided.
Logging:
- audit_logs: session_created, session_rotated, session_revoked (with session_id, masked ua/ip).
- security_events: refresh_reuse_detected, anomalous_device_detected.

## 3. JWT Access/Refresh Tokens with Rotation & Revocation [pending]
### Dependencies: 3.1, 3.2
### Description: Issue 30m JWT access tokens and 7d refresh tokens stored in httpOnly cookies; implement refresh rotation, revocation, and logout endpoints.
### Details:
Design:
- PyJWT 2.8; access token: 30m exp; claims: sub (user_id), role, scopes, sid (session id), iat, exp.
- Refresh token: random 256-bit opaque; 7d TTL; stored as httpOnly cookie; rotation on each refresh; detect reuse → revoke all in chain.
APIs:
- POST /auth/token/refresh → reads refresh cookie; 200 {access_token, expires_in}; sets new refresh cookie; 401 if invalid/revoked.
- POST /auth/logout → revoke current session; 204; clears refresh cookie.
- POST /auth/logout/all → revoke all sessions for user; 204; clears cookie.
Cookies:
- Name: rt; Path=/; HttpOnly; Secure; SameSite=Strict; Max-Age=604800; Domain configurable; Same attributes on rotation; clear on logout.
Errors:
- 401 ERR-TOKEN-INVALID, ERR-TOKEN-EXPIRED, ERR-TOKEN-REVOKED, ERR-REFRESH-REUSE.
- 400 ERR-TOKEN-MALFORMED.
Acceptance:
- Refresh rotates: old session revoked_at set; new session inserted; new cookie set with correct attributes.
- Reuse of an already-rotated refresh cookie triggers global revocation and 401.
- Access token in Authorization: Bearer <jwt> works for protected routes.
Logging:
- audit_logs: token_refreshed, logout, logout_all.
- security_events: refresh_reuse, invalid_refresh_cookie, suspicious_refresh_ip_change.

## 4. RBAC Enforcement via FastAPI Dependencies [pending]
### Dependencies: 3.3
### Description: Add role- and scope-based authorization using dependency injectors that read JWT claims.
### Details:
Design:
- Roles: user, admin; scopes per endpoint (e.g., designs:read, designs:write).
- Dependencies: require_auth(), require_role('admin'), require_scopes('x','y'). Reject if missing.
APIs:
- Example protected: GET /admin/users (admin only), GET /me (user).
Cookies: N/A.
Errors:
- 401 ERR-AUTH-REQUIRED (no/invalid token), 403 ERR-RBAC-FORBIDDEN (insufficient role/scope).
Acceptance:
- Endpoints annotated with dependencies enforce correct access; admin-only endpoints deny user role.
- Scope mismatch returns 403 without leaking resource existence.
Logging:
- security_events: rbac_forbidden (endpoint, required, provided), missing_auth_header.

## 5. Google OIDC (Authlib) with PKCE/State [pending]
### Dependencies: 3.3, 3.2
### Description: Integrate Google OIDC sign-in with PKCE and state validation; map oidc sub to user and issue session/tokens.
### Details:
Design:
- Authlib 1.3 OAuth2Client; use PKCE (S256) and state in server-side store; nonce in auth request.
- Persist mapping: oidc_accounts(user_id, provider='google', sub, email_verified, picture, created_at).
APIs:
- GET /auth/oidc/google/start → 302 redirect to Google (sets pkce_verifier in server store).
- GET /auth/oidc/google/callback?code&state → 302 to FE; on success set refresh cookie and return short-lived page that exchanges for access token if needed.
Cookies:
- Sets refresh cookie (rt) per Subtask 3 upon successful OIDC login.
Errors:
- 400 ERR-OIDC-STATE, 400 ERR-OIDC-NONCE, 401 ERR-OIDC-TOKEN-EXCHANGE, 409 ERR-OIDC-EMAIL-CONFLICT (if email claimed by another flow and policy forbids auto-link).
Acceptance:
- PKCE verifier and state validated; code exchange succeeds; new or existing user linked via sub.
- Audit log contains oidc_login with provider, sub; PII masked.
Logging:
- audit_logs: oidc_login_started, oidc_login_succeeded, oidc_login_linked.
- security_events: oidc_state_mismatch, oidc_token_exchange_failed.

## 6. Magic Link Issuance and Consumption [pending]
### Dependencies: 3.3
### Description: Provide passwordless login via single-use, 15-minute signed magic links with issuance and consumption endpoints.
### Details:
Design:
- Sign tokens with itsdangerous (TimedJSONWebSignatureSerializer) or HMAC; payload: {email, nonce, iat}.
- Persist single-use: magic_links(id, email, nonce, issued_at, consumed_at, ip, ua).
APIs:
- POST /auth/magic-link/request {email} → 202 {}; send email with URL (/auth/magic-link/consume?token=...). Rate limit applied.
- POST /auth/magic-link/consume {token, device_fingerprint?} → 200 {access_token, expires_in}; sets refresh cookie.
Cookies:
- On consume, set refresh cookie (rt) with Secure, HttpOnly, SameSite=Strict, Max-Age=7d.
Errors:
- 400 ERR-ML-MALFORMED, 401 ERR-ML-INVALID, 401 ERR-ML-EXPIRED, 409 ERR-ML-ALREADY-USED.
Acceptance:
- Token expires at 15m; cannot be reused; consuming creates session and returns access token.
- Email enumeration safe: request endpoint always 202.
Logging:
- audit_logs: magic_link_issued, magic_link_consumed.
- security_events: magic_link_invalid, magic_link_reuse_attempt.

## 7. TOTP MFA (pyotp) Setup, Verify, and Backup Codes [pending]
### Dependencies: 3.1, 3.3
### Description: Implement TOTP MFA for admins/sensitive actions with setup, verification during login, and optional backup codes.
### Details:
Design:
- pyotp TOTP (period=30, digits=6); store mfa_secret encrypted at rest; enforce for admin role and step-up on sensitive endpoints.
- Backup codes: 10 single-use codes (sha256 hashed) in mfa_backup_codes table.
APIs:
- POST /auth/mfa/setup/start → 200 {secret_masked, otpauth_url, qr_png_base64}.
- POST /auth/mfa/setup/verify {code} → 200 {} enables MFA.
- POST /auth/mfa/disable {code} → 200 {}.
- POST /auth/mfa/challenge {code or backup_code} → 200 {access_token} when login required step-up.
- GET /auth/mfa/backup-codes → 200 {codes_plaintext_once} (generate/regenerate).
Cookies:
- Uses refresh cookie issuance from Subtask 3 when MFA satisfied.
Errors:
- 401 ERR-MFA-REQUIRED, 401 ERR-MFA-INVALID, 409 ERR-MFA-ALREADY-ENABLED, 400 ERR-MFA-NOT-ENABLED.
Acceptance:
- Admin login without MFA triggers mfa_required; providing valid TOTP returns tokens.
- Backup codes consume once; disabling MFA requires valid TOTP.
Logging:
- audit_logs: mfa_enabled, mfa_challenge_succeeded, mfa_disabled.
- security_events: mfa_challenge_failed, backup_code_used.

## 8. CSRF Double-Submit Protection [pending]
### Dependencies: 3.3
### Description: Add double-submit CSRF for browser POST/PUT/PATCH/DELETE when Authorization header present.
### Details:
Design:
- Issue CSRF cookie and require X-CSRF-Token header matching cookie value for state-changing browser requests.
- Skip for non-browser clients (no cookies) and for idempotent GET/HEAD.
APIs:
- GET /auth/csrf-token → 200 {} and sets csrf cookie; FE reads cookie and mirrors into header.
Cookies:
- Name: csrf; HttpOnly=false; Secure=true; SameSite=Strict; Path=/; Max-Age=7200.
Errors:
- 403 ERR-CSRF-MISSING, 403 ERR-CSRF-MISMATCH.
Acceptance:
- Requests with valid X-CSRF-Token pass; mismatched or missing token returns 403.
- Token rotates periodically or on login; works with refresh cookie and Authorization header.
Logging:
- security_events: csrf_missing, csrf_mismatch (method, path, ua masked).

## 9. Rate Limiting with Redis [pending]
### Dependencies: None
### Description: Configure fastapi-limiter with Redis and apply per-route policies, including login 5/min and AI prompt 30/min.
### Details:
Design:
- fastapi-limiter with IP + user keying; trust X-Forwarded-For when behind proxy.
- Policies: /auth/login 5/min, /auth/magic-link/request 3/min, /auth/token/refresh 60/min per session, AI prompt endpoints 30/min per user.
APIs: N/A (decorators/middleware on endpoints).
Cookies: N/A.
Errors:
- 429 ERR-RATE-LIMIT with Retry-After header.
Acceptance:
- Exceeding thresholds yields 429; counters reset after window; per-user limits respect JWT sub.
Logging:
- security_events: rate_limited (route, key), potential_bruteforce_detected.

## 10. Security Headers and Input Sanitization [pending]
### Dependencies: None
### Description: Add Starlette middleware for CSP, HSTS, frame-ancestors deny, and sanitize inputs to mitigate XSS/Injection.
### Details:
Design:
- Headers: Content-Security-Policy (default-src 'self'; frame-ancestors 'none'; object-src 'none'), Strict-Transport-Security (max-age=31536000; includeSubDomains), X-Frame-Options: DENY, X-Content-Type-Options: nosniff, Referrer-Policy: no-referrer, Permissions-Policy minimal.
- Input sanitization: pydantic validation; strip HTML from text fields where applicable; encode outputs.
APIs: N/A.
Cookies: Ensure Secure and SameSite per auth cookies.
Errors: N/A.
Acceptance:
- Responses include required headers; sample reflective XSS payload is neutralized.
- SQLAlchemy ORM used to prevent SQLi patterns in queries.
Logging:
- security_events: csp_violation_report (if enabled), xss_attempt_detected.

## 11. Audit and Security Event Logging with PII Masking [pending]
### Dependencies: None
### Description: Implement structured audit and security logs with masking and correlation IDs; persist to audit_logs and security_events.
### Details:
Design:
- Log schema: {event_type, user_id?, session_id?, resource?, ip_masked, ua_masked, metadata, created_at, chain_hash} with optional hash-chaining.
- PII masking: emails partially masked (a***@d***), IP truncated.
- Correlation-ID per request; include in all logs and responses.
APIs:
- GET /admin/logs (admin) with filters and pagination.
Cookies: N/A.
Errors: 403 ERR-RBAC-FORBIDDEN for non-admin access.
Acceptance:
- All auth events generate audited entries; sensitive fields masked; chain hash verifies integrity.
- Logs queryable by correlation ID.
Logging:
- Applies across all other subtasks; provides emitters/utilities for consistent logging.

## 12. Dev-Mode Toggles and Production Hardening [pending]
### Dependencies: 3.3
### Description: Introduce dev-mode behaviors and enforce production-only security settings.
### Details:
Design:
- ENV DEV_MODE=true enables relaxed guards for local development (e.g., skip CSRF for localhost), annotate responses dev_mode=true; never enabled in prod.
- Enforce Secure cookies in prod; reject HTTP (redirect to HTTPS); disable detailed error traces in prod.
- Feature flags for test OIDC provider.
APIs: N/A.
Cookies:
- Validate cookie attributes vary by environment (Secure, SameSite strict in prod).
Errors: N/A.
Acceptance:
- In dev: convenience features active and flagged; in prod: strict headers and cookies enforced; misconfiguration logs warnings and refuses to start if critical secrets missing.
Logging:
- audit_logs: config_loaded (env summary sans secrets).
- security_events: insecure_config_detected (prod with insecure flags).

## 13. Frontend Auth Pages and Turkish i18n [pending]
### Dependencies: 3.1, 3.3, 3.5, 3.6, 3.8
### Description: Build Next.js pages for login/register, OIDC callback, and magic link; integrate React Hook Form and i18next (TR default).
### Details:
Design:
- Pages: /login, /register, /auth/oidc/callback, /auth/magic-link.
- React Hook Form with dynamic validation mirroring backend policy; i18next with TR default and EN fallback; localized error handling.
- Fetch flow: obtain CSRF token on app load; submit forms with X-CSRF-Token; store access token in memory (e.g., React state) and refresh via cookie.
APIs:
- Calls backend: /auth/register, /auth/login, /auth/oidc/google/start, /auth/magic-link/request, /auth/magic-link/consume, /auth/csrf-token.
Cookies:
- Reads CSRF cookie; backend manages refresh cookie; FE never stores refresh token.
Errors:
- Display localized messages for 401/403/429; map backend error codes to strings.
Acceptance:
- Turkish UI strings shown by default; validation errors inline; OIDC redirects correctly; magic link flow confirms email sent and consumes link successfully.
Logging:
- Client console/info logs minimized; no PII; send client telemetry (optional) with correlation ID if enabled.

## 14. Frontend Route Guards and Idle Logout [pending]
### Dependencies: 3.3, 3.13
### Description: Implement Next.js middleware and client guards to enforce auth and license checks; add idle timer auto-logout and banner.
### Details:
Design:
- middleware.ts: check for access token presence/validity (e.g., via lightweight endpoint or JWT decode) and redirect to /login; call /license/me to detect expiry → redirect to /license with banner of remaining days.
- Idle timer: logout after configurable inactivity (e.g., 15–30m); warn before logout; clear memory tokens and call /auth/logout.
APIs:
- GET /license/me → {status: active|expired, days_remaining}.
- POST /auth/logout.
Cookies:
- None handled directly; access token held in memory; refresh cookie managed by backend.
Errors:
- Redirect on 401; display localized toast on ERR-RBAC-FORBIDDEN when navigating to admin routes.
Acceptance:
- Unauthenticated user is redirected; expired license redirects with banner; idle logout triggers and clears session.
Logging:
- Client-side event logs (non-PII) for guard redirects and idle logout (optional analytics).

## 15. End-to-End and Security Tests [pending]
### Dependencies: 3.1, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7, 3.8, 3.9, 3.10, 3.11, 3.12, 3.13, 3.14
### Description: Automate E2E and security tests: Playwright flows, mocked OIDC, ZAP scan, CSRF/XSS/rate-limit verification.
### Details:
Design:
- Playwright: register→login (pwd), MFA challenge, OIDC login via mocked Google, magic link request→consume, refresh rotation, logout, license guard redirects, idle logout.
- Security: OWASP ZAP active scan against staging; CSRF negative tests; XSS reflection tests; rate-limit assertions (429 with Retry-After).
APIs: Exercise all relevant endpoints from other subtasks.
Cookies: Validate rt cookie attributes and CSRF cookie behaviors.
Errors:
- Assert specific codes/messages for failure paths (ERR-* from backend).
Acceptance:
- All happy paths pass; all negative paths return correct status and codes; ZAP reports no high/medium issues.
Logging:
- Verify audit/security events emitted for key actions and correlate via test-specific correlation IDs.

## 16. Documentation and Operational Playbooks [pending]
### Dependencies: 3.1, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7, 3.8, 3.9, 3.10, 3.11, 3.12, 3.13, 3.14, 3.15
### Description: Produce API docs, security notes, and runbooks for keys rotation, incidents, and day-2 operations.
### Details:
Design:
- API reference with schemas, error codes, and cookie attributes; sequence diagrams for login, refresh rotation, OIDC, magic link, MFA.
- Security guide: CSRF model, XSS defenses, header policies, RBAC model, rate-limits.
- Playbooks: JWT signing key rotation (kid, JWKS), refresh token compromise response (revoke chains), password pepper rotation strategy, OIDC client secret rotation, incident response steps, audit log review, backup/restore for auth tables.
APIs: N/A (documentation deliverables).
Cookies: Document rt and csrf attributes and lifetimes.
Errors: Document canonical ERR-* codes.
Acceptance:
- Docs reviewed and approved; includes examples and cURL snippets; on-call runbooks actionable with checklists.
Logging:
- Include logging taxonomy and examples; mapping of events to alerting.

