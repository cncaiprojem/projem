"""Artefact model for generated files and outputs.

Enterprise-grade file artifact tracking with strict Task Master ERD compliance.
"""

from datetime import datetime, timezone
from typing import Optional

from sqlalchemy import (
    String, BigInteger, ForeignKey, Index,
    DateTime, UniqueConstraint
)
from sqlalchemy.dialects.postgresql import JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship

from .base import Base, TimestampMixin


class Artefact(Base, TimestampMixin):
    """File artifacts generated by jobs.
    
    Task Master ERD Compliance:
    - job_id FK with CASCADE behavior for cleanup
    - type string field for artifact classification
    - s3_key unique field for file storage reference
    - size_bytes bigint for file size tracking
    - sha256 string for integrity verification
    - mime string for content type
    - meta JSONB for additional metadata
    - Enterprise security and audit trail
    """
    
    __tablename__ = "artefacts"
    
    # Primary key
    id: Mapped[int] = mapped_column(
        primary_key=True, 
        autoincrement=True
    )
    
    # Foreign key with CASCADE behavior per ERD
    job_id: Mapped[int] = mapped_column(
        ForeignKey("jobs.id", ondelete="CASCADE", name="fk_artefacts_job_id"),
        nullable=False,
        index=True
    )
    
    # Artifact classification (Task Master ERD requirement)
    type: Mapped[str] = mapped_column(
        String(50),
        nullable=False,
        index=True
    )
    
    # Storage reference (Task Master ERD requirement)
    s3_key: Mapped[str] = mapped_column(
        String(1024),
        unique=True,
        nullable=False
    )
    
    # File size tracking (Task Master ERD requirement)
    size_bytes: Mapped[int] = mapped_column(
        BigInteger,
        nullable=False
    )
    
    # Content integrity (Task Master ERD requirement)
    sha256: Mapped[Optional[str]] = mapped_column(
        String(64),
        nullable=True,
        index=True
    )
    
    # Content type (Task Master ERD requirement)
    mime: Mapped[Optional[str]] = mapped_column(
        String(100),
        nullable=True
    )
    
    # Additional metadata (Task Master ERD requirement)
    meta: Mapped[Optional[dict]] = mapped_column(
        JSONB,
        nullable=True
    )
    
    # Relationships
    job: Mapped["Job"] = relationship(
        "Job", 
        back_populates="artefacts",
        foreign_keys=[job_id]
    )
    
    # Enterprise-grade indexing strategy
    __table_args__ = (
        Index(
            'idx_artefacts_job_id_type', 
            'job_id', 
            'type'
        ),
        Index(
            'idx_artefacts_sha256', 
            'sha256',
            postgresql_where='sha256 IS NOT NULL'
        ),
        Index(
            'idx_artefacts_size_bytes', 
            'size_bytes'
        ),
        Index(
            'idx_artefacts_created_at', 
            'created_at'
        ),
        # GIN index for JSONB meta field (Task Master ERD optional requirement)
        Index(
            'idx_artefacts_meta_gin',
            'meta',
            postgresql_using='gin',
            postgresql_where='meta IS NOT NULL'
        )
    )
    
    def __repr__(self) -> str:
        """Developer-friendly representation."""
        return (
            f"<Artefact(id={self.id}, job_id={self.job_id}, "
            f"type={self.type}, size={self.size_mb:.2f}MB)>"
        )
    
    def __str__(self) -> str:
        """User-friendly representation."""
        return f"Artifact #{self.id} - {self.type} ({self.size_mb:.2f}MB)"
    
    @property
    def size_kb(self) -> float:
        """Get file size in kilobytes."""
        return self.size_bytes / 1024.0
    
    @property
    def size_mb(self) -> float:
        """Get file size in megabytes."""
        return self.size_bytes / (1024.0 * 1024.0)
    
    @property
    def size_gb(self) -> float:
        """Get file size in gigabytes."""
        return self.size_bytes / (1024.0 * 1024.0 * 1024.0)
    
    @property
    def has_integrity_check(self) -> bool:
        """Check if artifact has SHA-256 hash for integrity."""
        return bool(self.sha256)
    
    def get_meta(self, key: str, default=None):
        """Get metadata value safely."""
        if not self.meta:
            return default
        return self.meta.get(key, default)
    
    def set_meta(self, key: str, value) -> None:
        """Set metadata value safely."""
        if self.meta is None:
            self.meta = {}
        self.meta[key] = value
    
    def add_processing_info(
        self, 
        processing_time_ms: int,
        compression_ratio: Optional[float] = None,
        quality_score: Optional[float] = None
    ) -> None:
        """Add processing metadata."""
        self.set_meta('processing_time_ms', processing_time_ms)
        if compression_ratio is not None:
            self.set_meta('compression_ratio', compression_ratio)
        if quality_score is not None:
            self.set_meta('quality_score', quality_score)
        self.set_meta('processed_at', datetime.utcnow().isoformat())
    
    def verify_integrity(self, provided_hash: str) -> bool:
        """Verify file integrity using SHA-256 hash."""
        if not self.sha256:
            return False
        return self.sha256.lower() == provided_hash.lower()