"""
Task 7.18: Module Restrictions Generator

Utility to centralize Python module restrictions configuration.
Generates both Python code and shell scripts from a single source of truth.
"""

from pathlib import Path
from typing import Set, Dict, Optional
import json

from ..core.security_config import PythonModulePolicy, SecurityLevel


class ModuleRestrictionsGenerator:
    """Generate module restrictions for different environments."""
    
    def __init__(self, policy: Optional[PythonModulePolicy] = None):
        self.policy = policy or PythonModulePolicy()
    
    def generate_python_script(
        self, 
        security_level: SecurityLevel = SecurityLevel.PRODUCTION,
        output_path: Optional[Path] = None
    ) -> str:
        """Generate standalone Python restriction script."""
        allowed = self.policy.get_allowed_modules(security_level)
        blocked = self.policy.blocked_modules
        
        script = f'''#!/usr/bin/env python3
"""
Python startup script to restrict module imports and dangerous functions
Generated by ModuleRestrictionsGenerator for {security_level.value} environment
"""
import builtins
import sys

# Save original import
_original_import = builtins.__import__

# Define allowed modules
ALLOWED_MODULES = {sorted(allowed)!r}

# Define blocked modules
BLOCKED_MODULES = {sorted(blocked)!r}

def restricted_import(name, *args, **kwargs):
    """Restricted import function"""
    base_name = name.split('.')[0]
    
    if base_name in BLOCKED_MODULES:
        raise ImportError(f"Module '{{base_name}}' is blocked for security")
    
    if base_name not in ALLOWED_MODULES:
        raise ImportError(f"Module '{{base_name}}' is not allowed")
    
    return _original_import(name, *args, **kwargs)

# Replace import
builtins.__import__ = restricted_import

# Remove dangerous builtins (but NOT __import__ as it's already replaced)
# __import__ is needed for Python's import statement to work
for dangerous in ['eval', 'exec', 'compile']:
    if hasattr(builtins, dangerous):
        delattr(builtins, dangerous)

print("Python security restrictions applied")
'''
        
        if output_path:
            output_path.write_text(script)
            output_path.chmod(0o755)
        
        return script
    
    def generate_dockerfile_env(
        self, 
        security_level: SecurityLevel = SecurityLevel.PRODUCTION
    ) -> str:
        """Generate Dockerfile ENV commands for module restrictions."""
        allowed = self.policy.get_allowed_modules(security_level)
        blocked = self.policy.blocked_modules
        
        env_commands = []
        env_commands.append(f'ENV FREECAD_SECURITY_LEVEL="{security_level.value}"')
        env_commands.append(f'ENV PYTHON_ALLOWED_MODULES="{",".join(sorted(allowed))}"')
        env_commands.append(f'ENV PYTHON_BLOCKED_MODULES="{",".join(sorted(blocked))}"')
        
        return '\n'.join(env_commands)
    
    def generate_json_config(
        self,
        security_level: SecurityLevel = SecurityLevel.PRODUCTION,
        output_path: Optional[Path] = None
    ) -> Dict[str, Set[str]]:
        """Generate JSON configuration for module restrictions."""
        config = {
            "security_level": security_level.value,
            "allowed_modules": sorted(self.policy.get_allowed_modules(security_level)),
            "blocked_modules": sorted(self.policy.blocked_modules),
            "core_modules": sorted(self.policy.core_allowed)
        }
        
        if output_path:
            with open(output_path, 'w') as f:
                # Convert sets to lists for JSON serialization
                json_config = {
                    k: list(v) if isinstance(v, (set, list)) else v
                    for k, v in config.items()
                }
                json.dump(json_config, f, indent=2, sort_keys=True)
        
        return config
    
    def sync_to_shell_script(
        self,
        shell_script_path: Path,
        security_level: SecurityLevel = SecurityLevel.PRODUCTION
    ) -> None:
        """Update shell script with current module restrictions."""
        if not shell_script_path.exists():
            raise FileNotFoundError(f"Shell script not found: {shell_script_path}")
        
        # Generate new Python restriction script content
        new_script = self.generate_python_script(security_level)
        
        # Read current shell script
        shell_content = shell_script_path.read_text()
        
        # Find and replace the Python restriction script section
        start_marker = '    cat > "${SCRIPT_DIR}/restrict_python.py" << \'EOF\''
        end_marker = 'EOF\n\n    log_info "Hardened Dockerfile created"'
        
        if start_marker in shell_content and end_marker in shell_content:
            # Extract parts before and after the Python script
            before = shell_content.split(start_marker)[0]
            after = end_marker + shell_content.split(end_marker)[1]
            
            # Rebuild with new script
            new_shell_content = before + start_marker + '\n' + new_script + after
            
            # Write back
            shell_script_path.write_text(new_shell_content)
            print(f"Updated {shell_script_path} with new module restrictions")
        else:
            print(f"Warning: Could not find Python script section in {shell_script_path}")


def main():
    """Main function for CLI usage."""
    import argparse
    
    parser = argparse.ArgumentParser(description="Generate module restrictions")
    parser.add_argument(
        "--security-level",
        choices=["development", "staging", "production"],
        default="production",
        help="Security level"
    )
    parser.add_argument(
        "--output-python",
        type=Path,
        help="Output path for Python script"
    )
    parser.add_argument(
        "--output-json",
        type=Path,
        help="Output path for JSON config"
    )
    parser.add_argument(
        "--sync-shell",
        type=Path,
        help="Shell script path to sync"
    )
    
    args = parser.parse_args()
    
    security_level = SecurityLevel(args.security_level)
    generator = ModuleRestrictionsGenerator()
    
    if args.output_python:
        generator.generate_python_script(security_level, args.output_python)
        print(f"Generated Python script: {args.output_python}")
    
    if args.output_json:
        generator.generate_json_config(security_level, args.output_json)
        print(f"Generated JSON config: {args.output_json}")
    
    if args.sync_shell:
        generator.sync_to_shell_script(args.sync_shell, security_level)
        print(f"Synced shell script: {args.sync_shell}")


if __name__ == "__main__":
    main()